@using Daedalus_Orbis.Map
@attribute [StreamRendering]
@inject BrowserService Service
@inject UXEvents uxEvents
@rendermode InteractiveAuto
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager Navigation



@if (Loading)
{
    <h3>Loading...</h3>
}
else
{
    <svg xmlns="http://www.w3.org/2000/svg" @ref=inputElement width="@Width" height="@Height" tabindex="-1" @onmousedown="StartDrag" @onmousemove="Drag" @onmouseup="EndDrag">
        <MapDefinitions />
        @foreach (TileComponentData tile in Map.Tiles)
        {
            Vector2 center = tile.Center;
            center = Vector2.Scale(center, Scale);
            center = Vector2.Add(center, Origin);
            
            //All Tiles not visible in the window will be ignored.
            if (center.X < -100 || center.X > (Width + 100))
            {
                continue;
            }
            if (center.Y < -100 || center.Y > (Height + 100))
            {
                continue;
            }
            <TileComponent tile="tile" transform="@TransformString" TerrainBrush="TerrainBrush"/>
        }
        
    </svg>
}


@code {
    public MapComponentData? Map { get; set; }

    public Vector2yOrientation Orientation { get; set; } = new Vector2yOrientation();
    [Parameter]
    public Vector2 Size { get; set; } = new Vector2(100, 100);
    public float Scale { get; set; } = 1;
    [Parameter]
    public Vector2 Origin { get; set; } = new Vector2(0, 0);

    public int Height { get; set; }
    public int Width { get; set; }
    public string TransformString { get; set; } = "";

    public bool ControlPressed { get; set; } = false;
    public bool Dragging { get; set; } = false;
    public ToolType ActiveToolType;
    public TerrainType TerrainBrush;
    private HubConnection h;
    private ElementReference inputElement;
    //string user = Context
    public bool Loading = true;


    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();


        List<Tile> tiles = new List<Tile>();

        Map map = new Map(125);
        Map = new MapComponentData(map, Origin, Size);
        uxEvents.OnZoomIn += ZoomIn;
        uxEvents.OnZoomOut += ZoomOut;
        uxEvents.OnNewTool += UpdateToolType;
        uxEvents.OnNewTerrain += UpdateTerrainType;
        uxEvents.OnNewTileSelectedClient += NewTileSelected;
        h = new HubConnectionBuilder().WithUrl(Navigation.ToAbsoluteUri("/selectionhub")).Build();
        try
        {
            await h.StartAsync();
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
        Loading = false;

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await GetDimensions();
        if (firstRender)
        {
            //await inputElement.FocusAsync();

            //Map.Origin = new Vector2(Width, Height);
            foreach(TileComponentData tile in Map.Tiles)
            {
                tile.Center = Map.HexagonCenter(tile);
            }
            StateHasChanged();
        }


    }

    async Task GetDimensions()
    {
        try
        {
            var dimension = await Service.GetDimensions();
            Height = dimension.Height;
            Width = dimension.Width;
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

    }

    protected async void NewTileSelected(TileComponentData t)
    {
        //var user = Context
        //Console.WriteLine("Sent Message");
        //await h.SendAsync("NewSelection", t);
    }

    protected void ZoomIn()
    {
        if (Scale >= 1)
        {
            return;
        }

        Scale += 0.1f;

        Map.Size = Vector2.Scale(Size, Scale);

        GenerateTransformString();
    }

    protected void ZoomOut()
    {
        if (Scale <= 0.1)
        {
            return;
        }

        Scale -= 0.1f;

        Map.Size = Vector2.Scale(Size, Scale);

        GenerateTransformString();
    }

    protected void UpdateToolType(ToolType tt)
    {
        ActiveToolType = tt;
    }

    protected void UpdateTerrainType(TerrainType tt)
    {
        TerrainBrush = tt;
    }

    public void StartDrag(MouseEventArgs e)
    {
        if (ActiveToolType == ToolType.Move)
        {
            Dragging = true;
            DragOffset = Vector2.Subtract(Origin, new Vector2(e.ClientX, e.ClientY));
        }
    }

    public Vector2? DragOffset { get; set; }
    public Vector2 MapOffset { get; set; } = new Vector2(0, 0);
    public void Drag(MouseEventArgs e)
    {
        if (Dragging)
        {
            //I forgot what this does. Some weird vector stuff to move the Origin around
            Vector2 NewOgPos = Vector2.Add(new Vector2(e.ClientX,e.ClientY), DragOffset);
            //Not sure what Map Offset is used for and honestly not even sure what it is meant to be. Keeping it just in case
            MapOffset = Vector2.Subtract(NewOgPos,Origin);
            Origin = new Vector2(e.ClientX + DragOffset.X, e.ClientY + DragOffset.Y);

            GenerateTransformString();
        }
    }

    public void EndDrag (MouseEventArgs e)
    {
        Dragging = false;
    }

    public void GenerateTransformString()
    {
        TransformString = $"translate({Origin.X} {Origin.Y}) scale({Scale})";
    }
}